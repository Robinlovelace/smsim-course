{
    "contents" : "weights[,,4] <- weights[,,4] * weights[,,1] * weights[,,2] *  weights[,,3] \nind.agg[,,1] <- ind.agg[,,4]\n\n# re-weighting for constraint 1 via IPF \nfor (j in 1:nrow(cons)){\n  for(i in 1:ncol(con1)){\n    weights[which(ind.cat[,i] == 1),j,1] <- con1[j,i] / ind.agg[j,i,1]}}\nfor (i in 1:nrow(cons)){ # convert con1 weights back into aggregates\n  ind.agg[i,,2]   <- colSums(ind.cat * weights[,i,num.cons+1] * weights[,i,1])}\n# test the result\nind.agg[1:3,1:15,2]\ncons[1:3,1:15]\n\n# second constraint\nfor (j in 1:nrow(cons)){\n  for(i in 1:ncol(con2) + ncol(con1)){\n    weights[which(ind.cat[,i] == 1),j,2] <- cons[j,i] /ind.agg[j,i,2]}}  \nfor (i in 1:nrow(cons)){ # convert con2 back into aggregate\n  ind.agg[i,,3]   <- colSums(ind.cat * weights[,i,num.cons+1] * weights[,i,1] * weights[,i,2])}\nind.agg[1:3,1:15,3]\ncons[1:3,1:15]\n# third constraint\nfor (j in 1:nrow(cons)){\n  for(i in 1:ncol(con3) + ncol(con1) + ncol(con2)){\n    weights[which(ind.cat[,i] == 1),j,3] <- cons[j,i] /ind.agg[j,i,3]}}\nfor (i in 1:nrow(cons)){ # convert con3 back into aggregate\n  ind.agg[i,,4]   <- colSums(ind.cat * weights[,i,num.cons+1] * weights[,i,1] * weights[,i,2] * \n                               weights[,i,3])}\n# test the result\nind.agg[1:3,,4]\ncons[1:3,]",
    "created" : 1398264399199.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2853446290",
    "id" : "3CC27CC6",
    "lastKnownWriteTime" : 1398275105,
    "path" : "~/repos/smsim-course/data/cakeMap/e2.R",
    "project_path" : "data/cakeMap/e2.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}