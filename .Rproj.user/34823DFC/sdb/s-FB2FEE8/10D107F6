{
    "contents" : "############################################\n#### From the IPF-performance-testing github repo  \n#### https://github.com/Robinlovelace/IPF-performance-testing\n############################################\n\nnum.its <- 20 # how many iterations will we run?\n\n# Loading the data: Ensure R is in the right working directory \nind <- read.csv(\"data/cakeMap/ind.csv\")\ncons <- read.csv(\"data/cakeMap/cons.csv\")\n\n# load constraints separately - normally this would be first stage\ncon1 <- cons[1:12]\ncon2 <- cons[13:14]\ncon3 <- cons[15:24]\n\nnum.cons <- 3  # n. constraints - can set automatically: length(which(grepl(\"con[1-9]\",ls()))))\ncategory.labels <- names(cons) # should be correct from cons.R\n\n# set-up aggregate values - column for each category\nsource(\"data/cakeMap/categorise.R\") # this script must be customised to input data\n\n# check constraint totals - should be true\nsum(ind.cat[,1:ncol(con1)]) == nrow(ind) # is the number in each category correct?\nsum(ind.cat[,ncol(con1)+1:ncol(con2)]) == nrow(ind) \n\n# create weights in 3D matrix (individuals, areas, iteration)\nweights <- array(dim=c(nrow(ind),nrow(cons),num.cons+1)) \nweights[,,1] <- 1 # sets initial weights to 1\n\n# convert survey data into aggregates to compare with census (3D matix)\nind.agg <- array(dim=c(nrow(cons),ncol(cons),num.cons+1))\nfor (i in 1:nrow(cons)){\n  ind.agg[i,,1]   <- colSums(ind.cat) * weights[1,i,1]}\nind.agg[1:5,1:10,1] # look at what we've created - n. individuals replicated throughout\n\n############## The IPF part #############\n\n# Re-weighting for constraint 1 via IPF \nfor (j in 1:nrow(cons)){\n  for(i in 1:ncol(con1)){\n weights[which(ind.cat[,i] == 1),j,2] <- con1[j,i] / ind.agg[j,i,1]}}\nfor (i in 1:nrow(cons)){ # convert con1 weights back into aggregates\n  ind.agg[i,,2]   <- colSums(ind.cat * weights[,i,1] * weights[,i,2])}\n# test results for first row (not necessary for model)\nind.agg[1,1:15,2] - cons[1,1:15] # should be zero for age/sex\n\n# second constraint\nfor (j in 1:nrow(cons)){\n  for(i in 1:ncol(con2) + ncol(con1)){\n  weights[which(ind.cat[,i] == 1),j,3] <- cons[j,i] / ind.agg[j,i,2]}}  \nfor (i in 1:nrow(cons)){ # convert con2 back into aggregate\nind.agg[i,,3] <- colSums(ind.cat * weights[,i,1] * weights[,i,2] * weights[,i,3])}\nind.agg[1,,3] - cons[1,] # should be close to zero for new constraint\n\n# third constraint\nfor (j in 1:nrow(cons)){\n  for(i in 1:ncol(con3) + ncol(con1) + ncol(con2)){\n    weights[which(ind.cat[,i] == 1),j,4] <- cons[j,i] / ind.agg[j,i,3]}}\nfor (i in 1:nrow(cons)){ # convert con3 back into aggregate\n  ind.agg[i,,4]   <- colSums(ind.cat * weights[,i,1] * weights[,i,2] * weights[,i,3] * weights[,i,4])}\nind.agg[1:3,,4] - cons[1:3,] # test the result\n\n# for multiple iterations\nwf <- array(dim=c(dim(weights), num.its, 1)) # array to store weights its, wei\nindf <- array(dim=c(dim(ind.agg), num.its, 1))\nwf[,,,1,1] <- weights \nindf[,,,1,1] <- ind.agg\n\n############## The multiple iterations #############\n\n# loop for multiple iterations (run e2.R repeatedly, saving each time)\nfor(it in 2:num.its){\nsource(file=\"data/cakeMap/e2.R\")\nwf[,,,it,1] <- weights\nindf[,,,it,1] <- ind.agg\n}\nfw <- weights[,,1] * weights[,,2] * weights[,,3] * weights[,,4] # save final weights (not done in 'e2.R')\n\n############## The analysis part #############\na.v <- as.vector(as.matrix(cons)) # constraints in long form, for cor\ng.v <- as.vector(as.matrix(indf[,,1,2,1]))\ncor(a.v,g.v)\n\nt1 <- data.frame(it = 1, corr = cor(a.v,g.v))\nt1 <- t1[0,]\nfor(it in 1:num.its){\n  for(con in 2:(num.cons+1)){\n    g.v <- as.vector(as.matrix(indf[,,con,it,1]))\n    t1[nrow(t1)+1,] <- c(it+con/10,cor(a.v,g.v))\n  }\n}\nt1$numit<-1:nrow(t1)\n\n############## Plot the results #############\n# plot the increasing fit, one interation to the next \nbarplot(height=t1[,2], names.arg=t1[,1], ylim=c(t1[1,2],1), ylab=(\"Correlation (r)\"))\n\n# now integerise if integer results are required (uncomment one of the lines below)\n# source(\"data/cakeMap/pp-integerise.R\") # creates integer output (intall) and cakes\n# source(\"data/cakeMap/TRS-integerise.R\") # the TRS strategy\n",
    "created" : 1398062323008.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "896773019",
    "id" : "10D107F6",
    "lastKnownWriteTime" : 1410592641,
    "path" : "~/repos/smsim-course/cMap.R",
    "project_path" : "cMap.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}